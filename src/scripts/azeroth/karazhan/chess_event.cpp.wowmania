/* Copyright (C) 2006 - 2008 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/* ScriptData
SDName: Chess_Event
SD%Complete: xx
SDComment: Baset on Hectolight script.
SDCategory: Karazhan

  I think locking and unlocking cells for unit movement is done. only need to add code to unlock it when creature dies :]
  
TODO:
 - Disable rotate for all chess pieces
 - Disable movement for unit controlled by player
 - Teleport players to the balkony when possesing creature
 - Improve finding creature in front and strafe ( maybe when rotate will be disabled it won't be needed :])
 - Update instance_karazhan for now it was done only to start it ;]
 - Implement Attack Creature when is in Front or Strafe(for every chesspieces ??) with proper factions.
 - Implement in instance_karazhan dead chess_piece count per side to allow Medivh to cheat when is loosing.(Or different terms was used as a treshold for cheat ?)
 - Prevent Reset() call when player unpossess creature.
 - Set proper position on left or right site from chess board for killed units.
 - and many more .. 
EndScriptData */

#include "precompiled.h"
#include "def_karazhan.h"

#define A_FACTION               1690
#define H_FACTION               1691

#define GOSSIP_POSSES           "[ Control this Chesspiece ]"     // Maybe should be different gossip, visuals will be fixed at the end :]

#define EVENT_START             "[PH] Start Chess Event"            // Maybe should be different gossip, visuals will be fixed at the end :]
#define NPC_ATTACK_RADIUS       7
#define AGGRO_RANGE             1
#define TRIGGER_ID              22519
#define SEARCH_RANGE            5
#define DUST_COVERED_CHEST      185119

enum eScriptTexts {
    SCRIPTTEXT_AT_EVENT_START   =  -1650000,
    SCRIPTTEXT_LOSE_KNIGHT_P    =  -1650001,
    SCRIPTTEXT_LOSE_KNIGHT_M    =  -1650002,
    SCRIPTTEXT_LOSE_PAWN_P_1    =  -1650003,
    SCRIPTTEXT_LOSE_PAWN_P_2    =  -1650004,
    SCRIPTTEXT_LOSE_PAWN_P_3    =  -1650005,
    SCRIPTTEXT_LOSE_PAWN_M_1    =  -1650006,
    SCRIPTTEXT_LOSE_PAWN_M_2    =  -1650007,
    SCRIPTTEXT_LOSE_PAWN_M_3    =  -1650008,
    SCRIPTTEXT_LOSE_QUEEN_P     =  -1650009,
    SCRIPTTEXT_LOSE_QUEEN_M     =  -1650010,
    SCRIPTTEXT_LOSE_BISHOP_P    =  -1650011,
    SCRIPTTEXT_LOSE_BISHOP_M    =  -1650012,
    SCRIPTTEXT_LOSE_ROOK_P      =  -1650013,
    SCRIPTTEXT_LOSE_ROOK_M      =  -1650014,
    SCRIPTTEXT_PLAYER_CHECK     =  -1650015,
    SCRIPTTEXT_MEDIVH_CHECK     =  -1650016,
    SCRIPTTEXT_PLAYER_WIN       =  -1650017,
    SCRIPTTEXT_MEDIVH_WIN       =  -1650018,
    SCRIPTTEXT_MEDIVH_CHEAT_1   =  -1650019,
    SCRIPTTEXT_MEDIVH_CHEAT_2   =  -1650020,
    SCRIPTTEXT_MEDIVH_CHEAT_3   =  -1650021
};

enum eNPCs { 
    NPC_MEDIVH   = 16816,
    NPC_PAWN_H   = 17469,
    NPC_PAWN_A   = 17211,
    NPC_KNIGHT_H = 21748,
    NPC_KNIGHT_A = 21664,
    NPC_QUEEN_H  = 21750,
    NPC_QUEEN_A  = 21683,
    NPC_BISHOP_H = 21747,
    NPC_BISHOP_A = 21682,
    NPC_ROOK_H   = 21726,
    NPC_ROOK_A   = 21160,
    NPC_KING_H   = 21752,
    NPC_KING_A   = 21684
};

enum eSpells {
    BISHOP_HEAL_H  = 37456,
    BISHOP_HEAL_A  = 37455,
    SPELL_MOVE_1   = 37146,
    SPELL_MOVE_2   = 30012,
    SPELL_MOVE_3   = 37144,
    SPELL_MOVE_4   = 37148,
    SPELL_MOVE_5   = 37151,
    SPELL_MOVE_6   = 37152,
    SPELL_MOVE_7   = 37153,

    SPELL_CHANGE_FACING     = 30284,
    SPELL_MOVE_MARKER       = 32261,
    SPELL_POSSES_CHESSPIECE = 30019,
    SPELL_HAND_OF_MEDIVH    = 39339, // 1st cheat: AOE spell burn cell under enemy chesspieces.
    SPELL_FURY_OF_MEDIVH    = 39383  // 2nd cheat: Berserk own chesspieces.
    // 3rd cheat: set own creatures to max health
};

bool HasKingBeenCharmed = false;        // No piece should move before the faction's King has been charmed

struct move_triggerAI : public ScriptedAI
{
    move_triggerAI(Creature *c) : ScriptedAI(c)
    {
        pInstance = ((ScriptedInstance*)m_creature->GetInstanceData());
    }

    ScriptedInstance* pInstance;
    
    Unit* onMarker;
    bool EndMarker;

    void Reset()
    {
        onMarker    = NULL;
        EndMarker   = false;
    }
    
    void Aggro(Unit* pWho) {}
    
    void SpellHit(Unit* pCaster, const SpellEntry* pSpell)
    {
        if(pSpell->Id == SPELL_CHANGE_FACING)
            pCaster->SetInFront(m_creature);

        if(pSpell->Id == SPELL_MOVE_1 || pSpell->Id == SPELL_MOVE_2 || pSpell->Id == SPELL_MOVE_3 || pSpell->Id == SPELL_MOVE_4 ||
           pSpell->Id == SPELL_MOVE_5 || pSpell->Id == SPELL_MOVE_6 || pSpell->Id == SPELL_MOVE_7)
        {

            if(onMarker != NULL || EndMarker)
                return;

            EndMarker = true;
            onMarker = pCaster;
            
            DoCast(m_creature, SPELL_MOVE_MARKER);
            pCaster->GetMotionMaster()->Clear();
            pCaster->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ());
        }
    }
    
    void UpdateAI(const uint32 diff)
    {
        if(pInstance->GetData(DATA_CHESS_EVENT) != IN_PROGRESS)
            return;
            
        if(onMarker) {
            if(onMarker->isAlive()) // Better check it here so we don't need to find start and end marker when chess wie die in move without reaching destination point :]
                return;
            else
                Reset();
        }
    }
};

struct npc_chesspieceAI : public Scripted_NoMovementAI
{
    npc_chesspieceAI(Creature *c) : Scripted_NoMovementAI(c)
    {
        pInstance = ((ScriptedInstance*)m_creature->GetInstanceData());

        SpellEntry* TempSpell = (SpellEntry*)GetSpellStore()->LookupEntry(SPELL_POSSES_CHESSPIECE);
        if (TempSpell)
            TempSpell->Effect[0] = 0;  // Disable bind sight effect from SPELL_POSSES_CHESSPIECE. We handle all with dummy and charm effect.
    }
    
    ScriptedInstance* pInstance;
    
    Unit* npc_medivh;
    
    bool ReturnToHome;
    bool InGame;
    bool CanMove;
    
    uint32 Heal_Timer;
    uint32 NextMove_Timer;
    uint64 MedivhGUID;

    Creature *start_marker, *end_marker;

    std::list<Unit *> PossibleMoveUnits;

    /*void MoveInLineOfSight(Unit *who)
    {
        if( !m_creature->getVictim() && who->isTargetableForAttack() )
        {
            if (!m_creature->canFly() && m_creature->GetDistanceZ(who) > CREATURE_Z_ATTACK_RANGE)
                return;

                if( m_creature->IsWithinDistInMap(who, AGGRO_RANGE) && m_creature->IsWithinLOSInMap(who) && InGame)
                    AttackStart(who);
            }
        }
    }*/
    
    void Aggro(Unit* pWho)
    {
        MedivhGUID = pInstance->GetData64(DATA_CHESS_ECHO_OF_MEDIVH);
        npc_medivh = Unit::GetUnit(*m_creature, MedivhGUID);
        
        if (npc_medivh) {
            switch (pInstance->GetData(CHESS_EVENT_TEAM)) {
            case ALLIANCE:
                if (m_creature->GetEntry() == NPC_KING_H)
                    DoScriptText(SCRIPTTEXT_MEDIVH_CHECK, npc_medivh);
                else if (m_creature->GetEntry() == NPC_KING_A)
                    DoScriptText(SCRIPTTEXT_PLAYER_CHECK, npc_medivh);
            break;
            case HORDE:
                if (m_creature->GetEntry() == NPC_KING_A)
                    DoScriptText(SCRIPTTEXT_MEDIVH_CHECK, npc_medivh);
                else if (m_creature->GetEntry() == NPC_KING_H)
                    DoScriptText(SCRIPTTEXT_PLAYER_CHECK, npc_medivh);
            break;
            }
        }
    }
    
    void Reset()
    {
        ReturnToHome = true;
        Heal_Timer = 7000;
        InGame = true;
        CanMove = false;
        NextMove_Timer = 4500; // wait 4.5s for first moves
        m_creature->setActive(true);
        
        start_marker = NULL;
        end_marker = NULL;
    }
    
    void MovementInform(uint32 MovementType, uint32 Data)
    {
        if (MovementType != POINT_MOTION_TYPE)
            return;

        if (start_marker) {
            ((move_triggerAI*)start_marker->AI())->Reset();
            DoSay("Start Cell - Clear!", LANG_UNIVERSAL, false); // only for debug purposes :]
        }
    }
    
    void JustRespawned()
    {
        //not finally - just a presentation - need 32place two side of chesstable
        float angle = m_creature->GetOrientation();
        float pos_x = -11066;
        float pos_y = -1898;
        int move_lenght = 2*rand()%10;
        float new_x = pos_x + move_lenght * cos(angle);
        float new_y = pos_y + move_lenght * sin(angle);
        m_creature->Relocate(new_x, new_y, 221, 2.24);
        m_creature->CombatStop();
        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
    }
    
    void OnCharmed(bool apply)
    {
        if (pInstance->GetData(CHESS_EVENT_TEAM) == ALLIANCE) {
            switch (m_creature->GetEntry()) {
            case NPC_KING_A:
                HasKingBeenCharmed = true;
                break;
            }
        }
        else {
            switch (m_creature->GetEntry()) {
            case NPC_KING_H:
                HasKingBeenCharmed = true;
                break;
            }
        }
        
        // Place to disable rotate and move for player on possess
        if (apply) {
            /*m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_ROTATE);
            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);*/
            //m_creature->SetSpeed(MOVE_RUN, 0.0f, true);
            sLog.outString("applying root");
            m_creature->addUnitState(UNIT_STAT_ROOT);
        }
        else {
            /*m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_ROTATE);
            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_MOVE);*/
            //m_creature->SetSpeed(MOVE_RUN, 1.0f, true);
            sLog.outString("removing root");
            m_creature->clearUnitState(UNIT_STAT_ROOT);
        }
    }
    
    void JustDied(Unit* pKiller)
    { 
        MedivhGUID = pInstance->GetData64(DATA_CHESS_ECHO_OF_MEDIVH);
        npc_medivh = Unit::GetUnit(*m_creature, MedivhGUID);

        if (npc_medivh && pInstance->GetData(CHESS_EVENT_TEAM) == HORDE) {
            switch (m_creature->GetEntry()) {
            case NPC_ROOK_H:   DoScriptText(SCRIPTTEXT_LOSE_ROOK_P, npc_medivh);     break;
            case NPC_ROOK_A:   DoScriptText(SCRIPTTEXT_LOSE_ROOK_M, npc_medivh);     break;
            case NPC_QUEEN_H:  DoScriptText(SCRIPTTEXT_LOSE_QUEEN_P, npc_medivh);    break;
            case NPC_QUEEN_A:  DoScriptText(SCRIPTTEXT_LOSE_QUEEN_M, npc_medivh);    break;
            case NPC_BISHOP_H: DoScriptText(SCRIPTTEXT_LOSE_BISHOP_P, npc_medivh);   break;
            case NPC_BISHOP_A: DoScriptText(SCRIPTTEXT_LOSE_BISHOP_M, npc_medivh);   break;
            case NPC_KNIGHT_H: DoScriptText(SCRIPTTEXT_LOSE_KNIGHT_P, npc_medivh);   break;
            case NPC_KNIGHT_A: DoScriptText(SCRIPTTEXT_LOSE_KNIGHT_M, npc_medivh);   break;
            case NPC_PAWN_H:
                DoScriptText(RAND(SCRIPTTEXT_LOSE_PAWN_P_1, SCRIPTTEXT_LOSE_PAWN_P_2, SCRIPTTEXT_LOSE_PAWN_P_3), npc_medivh); break;
            case NPC_PAWN_A:
                DoScriptText(RAND(SCRIPTTEXT_LOSE_PAWN_M_1, SCRIPTTEXT_LOSE_PAWN_M_2), npc_medivh); break;
            case NPC_KING_H:
                DoScriptText(SCRIPTTEXT_MEDIVH_WIN, npc_medivh);
                pInstance->SetData(DATA_CHESS_EVENT, FAIL);
                break;
            case NPC_KING_A:
                DoScriptText(SCRIPTTEXT_PLAYER_WIN, npc_medivh);
                pInstance->SetData(DATA_CHESS_EVENT, DONE);
                m_creature->SummonGameObject(DUST_COVERED_CHEST, -11058, -1903, 221, 2.24, 0, 0, 0, 0, 7200000);
                break;
            default: break;
            }
        }
        else if (npc_medivh) {
            switch(m_creature->GetEntry()) {
            case NPC_ROOK_A:   DoScriptText(SCRIPTTEXT_LOSE_ROOK_P, npc_medivh);     break;
            case NPC_ROOK_H:   DoScriptText(SCRIPTTEXT_LOSE_ROOK_M, npc_medivh);     break;
            case NPC_QUEEN_A:  DoScriptText(SCRIPTTEXT_LOSE_QUEEN_P, npc_medivh);    break;
            case NPC_QUEEN_H:  DoScriptText(SCRIPTTEXT_LOSE_QUEEN_M, npc_medivh);    break;
            case NPC_BISHOP_A: DoScriptText(SCRIPTTEXT_LOSE_BISHOP_P, npc_medivh);   break;
            case NPC_BISHOP_H: DoScriptText(SCRIPTTEXT_LOSE_BISHOP_M, npc_medivh);   break;
            case NPC_KNIGHT_A: DoScriptText(SCRIPTTEXT_LOSE_KNIGHT_P, npc_medivh);   break;
            case NPC_KNIGHT_H: DoScriptText(SCRIPTTEXT_LOSE_KNIGHT_M, npc_medivh);   break;
            case NPC_PAWN_A:
                DoScriptText(RAND(SCRIPTTEXT_LOSE_PAWN_P_1, SCRIPTTEXT_LOSE_PAWN_P_2, SCRIPTTEXT_LOSE_PAWN_P_3), npc_medivh); break;
            case NPC_PAWN_H:
                DoScriptText(RAND(SCRIPTTEXT_LOSE_PAWN_M_1, SCRIPTTEXT_LOSE_PAWN_M_2), npc_medivh); break;
            case NPC_KING_A:
                DoScriptText(SCRIPTTEXT_MEDIVH_WIN, npc_medivh);
                pInstance->SetData(DATA_CHESS_EVENT, FAIL);
                break;
            case NPC_KING_H:
                DoScriptText(SCRIPTTEXT_PLAYER_WIN, npc_medivh);
                pInstance->SetData(DATA_CHESS_EVENT, DONE);
                m_creature->SummonGameObject(DUST_COVERED_CHEST, -11058, -1903, 221, 2.24, 0, 0, 0, 0, 7200000);
                break;
            default: break;
            }
        }
        else
            DoSay("Medivh not found / bad data", LANG_UNIVERSAL, false); // Only for me for debug :]
        
        if (m_creature->isPossessed())
            m_creature->RemoveCharmedOrPossessedBy(m_creature->GetCharmer());
            
        InGame = false;
        m_creature->setActive(false);
        m_creature->Respawn();

    }

    std::list<Unit*> FindPossibleMoveUnits()
    {
        CellPair p(Trinity::ComputeCellPair(m_creature->GetPositionX(), m_creature->GetPositionY()));
        Cell cell(p);
        cell.data.Part.reserved = ALL_DISTRICT;
        cell.SetNoCreate();

        std::list<Unit*> pList;
        std::list<Unit*> returnList;
        
        float range = GetStrafeLenght(m_creature->GetEntry())*SEARCH_RANGE;

        Trinity::AllCreaturesOfEntryInRange u_check(m_creature, TRIGGER_ID, range);
        Trinity::UnitListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher(pList, u_check);
        TypeContainerVisitor<Trinity::UnitListSearcher<Trinity::AllCreaturesOfEntryInRange>, GridTypeMapContainer >  grid_unit_searcher(searcher);

        CellLock<GridReadGuard> cell_lock(cell, p);
        cell_lock->Visit(cell_lock, grid_unit_searcher, *(m_creature->GetMap()));
    
        for(std::list<Unit *>::iterator itr = pList.begin(); itr != pList.end(); itr++)
        {
            if((*itr)->GetEntry() != TRIGGER_ID || ((move_triggerAI*)((Creature*)(*itr))->AI())->onMarker != NULL || !m_creature->isInFront((*itr), 5.0f, 2*M_PI/6)) // TODO: Need better check to exclude triggers not in front or not at strafe.
                continue;
    
            returnList.push_back((*itr));
        }
    
        pList.clear();
        return returnList;
    }
    
    int GetStrafeLenght(uint32 Entry)
    {
        if (Entry == NPC_QUEEN_H || Entry == NPC_QUEEN_A)
            return 2;
        
        return 1;
    }

    void UpdateAI(const uint32 diff)
    {
        if (pInstance->GetData(DATA_CHESS_EVENT) == DONE || pInstance->GetData(DATA_CHESS_EVENT) == FAIL) {
            if(m_creature->isInCombat())
                m_creature->CombatStop();            

            if(m_creature->isPossessed())
                m_creature->RemoveCharmedOrPossessedBy(m_creature->GetCharmer());

            if(m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);

            if(ReturnToHome) {
                m_creature->GetMotionMaster()->Clear();
                m_creature->GetMotionMaster()->MoveTargetedHome();
                ReturnToHome = false;
            }
        }
        
        if (pInstance->GetData(DATA_CHESS_EVENT) != IN_PROGRESS)
            return;
            
        if (!HasKingBeenCharmed)
            return;
            
        //if (!m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_ROTATE))
            //m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_ROTATE); // that state disallow player to use spell's from pet bar. Need to change that and also need to disable move :]

        if (!ReturnToHome) // for fail
            ReturnToHome = true;

        if (!InGame)
            return;

        if (!m_creature->isPossessed()) {
            if (!CanMove) {
                if(NextMove_Timer < diff) {
                    CanMove = true;
                    
                    start_marker = end_marker;
                    end_marker = NULL;
                    
                    NextMove_Timer = 10000;
                } else NextMove_Timer -= diff;
            }

            if (!m_creature->getVictim()) {
                if(!CanMove)
                    return;

                PossibleMoveUnits = FindPossibleMoveUnits();
                
                if(PossibleMoveUnits.empty())
                    return;
                
                std::list<Unit*>::iterator i = PossibleMoveUnits.begin();
                advance (i ,rand()%PossibleMoveUnits.size());
                
                end_marker = (Creature*)(*i);
                
                if (((move_triggerAI*)end_marker->AI())->onMarker != NULL && !((move_triggerAI*)end_marker->AI())->EndMarker) {             
                    for(uint8 x = 0; x<PossibleMoveUnits.size(); x++) {
                        i = PossibleMoveUnits.begin();
                        advance(i, x);
                        
                        end_marker = (Creature*)(*i);
                        
                        if(!((move_triggerAI*)end_marker->AI())->EndMarker) {
                            DoCast((*i), SPELL_MOVE_1);
                            break;
                        }
                    }
                }
                else
                    DoCast((*i), SPELL_MOVE_1);

                CanMove = false;
                NextMove_Timer = 6000;
            }
                
            switch(m_creature->GetEntry()) {
            case NPC_BISHOP_A:
                if(Heal_Timer <= diff) {
                    Unit* target = DoSelectLowestHpFriendly(25, 5000); //dont select player controlled unit
                    
                    if(target)
                        DoCast(target, BISHOP_HEAL_A);
                
                    Heal_Timer = 21000;
                } else Heal_Timer -= diff;
                break;
            case NPC_BISHOP_H:
                if(Heal_Timer <= diff) {
                    Unit* target = DoSelectLowestHpFriendly(25,5000); //dont select player controlled unit
                    
                    if(target)
                        DoCast(target, BISHOP_HEAL_H);
                
                    Heal_Timer = 21000;
                } else Heal_Timer -= diff;
                break;
            default:        break;
            }
            
            if (m_creature->getVictim() || !m_creature->IsWithinDistInMap(m_creature->getVictim(), NPC_ATTACK_RADIUS)) {
                m_creature->CombatStop();
                return;
            }
        }
        
        DoMeleeAttackIfReady();
    }
    
    void SpellHitTarget(Unit *target, const SpellEntry* spell)
    {
        if (target->GetEntry() != TRIGGER_ID || (spell->Id != SPELL_MOVE_1
           && spell->Id != SPELL_MOVE_2 && spell->Id != SPELL_MOVE_3 && spell->Id != SPELL_MOVE_4
           && spell->Id != SPELL_MOVE_5 && spell->Id != SPELL_MOVE_6 && spell->Id != SPELL_MOVE_7) )
            return;

        if (m_creature->isPossessed()) {
            Creature* marker = (Creature*)target;
            if(marker && ((move_triggerAI*)marker->AI())->onMarker == m_creature) {
                start_marker = end_marker;
                end_marker = (Creature*)target;
            }
        }
    }
};

bool GossipHello_npc_chesspiece(Player* pPlayer, Creature* pCreature)
{
    ScriptedInstance* pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
    
    if (pInstance->GetData(DATA_CHESS_EVENT) != IN_PROGRESS)
        return true;
    
    if (pInstance->GetData(CHESS_EVENT_TEAM) == ALLIANCE && pCreature->getFaction() != A_FACTION)
        return true;
    
    if (pInstance->GetData(CHESS_EVENT_TEAM) == HORDE && pCreature->getFaction() != H_FACTION)
        return true;
    
    if (!pCreature->isPossessedByPlayer()) {
        pPlayer->ADD_GOSSIP_ITEM(0, GOSSIP_POSSES, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
        pPlayer->SEND_GOSSIP_MENU(8990, pCreature->GetGUID());
    }
    return true;
}

bool GossipSelect_npc_chesspiece(Player* pPlayer, Creature* pCreature, uint32 sender, uint32 action)
{
    if (action == GOSSIP_ACTION_INFO_DEF + 1) {
        pPlayer->CastSpell(pCreature, SPELL_POSSES_CHESSPIECE, false);
        //player->TeleportTo(532,-11087,-1899,221,0,0);
    }

    pPlayer->CLOSE_GOSSIP_MENU();
    return true;
}

bool GossipHello_npc_echo_of_medivh(Player* pPlayer, Creature* pCreature)
{
    ScriptedInstance* pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());
    
    if (pInstance->GetData(DATA_CHESS_EVENT) == FAIL)
        pInstance->SetData(DATA_CHESS_EVENT, NOT_STARTED);

    if (pInstance->GetData(DATA_CHESS_EVENT) == DONE) //for testing
        pInstance->SetData(DATA_CHESS_EVENT, NOT_STARTED); 

    if (pInstance->GetData(DATA_CHESS_EVENT) != NOT_STARTED)
        return true;

    pPlayer->ADD_GOSSIP_ITEM(0, EVENT_START, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
    pPlayer->SEND_GOSSIP_MENU(8990, pCreature->GetGUID());
    
    return true;
}

bool GossipSelect_npc_echo_of_medivh(Player* pPlayer, Creature* pCreature, uint32 sender, uint32 action)
{
    ScriptedInstance* pInstance = ((ScriptedInstance*)pCreature->GetInstanceData());

    if (action == GOSSIP_ACTION_INFO_DEF + 1) {
        DoScriptText(SCRIPTTEXT_AT_EVENT_START, pCreature);
        pInstance->SetData(DATA_CHESS_EVENT, IN_PROGRESS);
        pInstance->SetData(CHESS_EVENT_TEAM, pPlayer->GetTeam());
        pCreature->GetMotionMaster()->MoveConfused();
        HasKingBeenCharmed = false;
        //player->TeleportTo(-11054.032,-1909.979,229.626,2.190);
    }

    pPlayer->CLOSE_GOSSIP_MENU();
    
    return true;
}

CreatureAI* GetAI_npc_chesspiece(Creature* pCreature)
{
    return new npc_chesspieceAI(pCreature);
}

CreatureAI* GetAI_move_trigger(Creature* pCreature)
{
    return new move_triggerAI(pCreature);
}

void AddSC_chess_event()
{
    Script* newscript;

    newscript = new Script;
    newscript->Name = "npc_chesspiece";
    newscript->GetAI = &GetAI_npc_chesspiece;
    newscript->pGossipHello = GossipHello_npc_chesspiece;
    newscript->pGossipSelect = GossipSelect_npc_chesspiece;
    newscript->RegisterSelf();

    newscript = new Script;
    newscript->Name = "npc_echo_of_medivh";
    newscript->pGossipHello = GossipHello_npc_echo_of_medivh;
    newscript->pGossipSelect = GossipSelect_npc_echo_of_medivh;
    newscript->RegisterSelf();

    newscript = new Script;
    newscript->Name = "chess_move_trigger";
    newscript->GetAI = &GetAI_move_trigger;
    newscript->RegisterSelf();
}
